% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/generics.R
\name{inclusion_prob}
\alias{inclusion_prob}
\alias{inclusion_prob.wor}
\alias{inclusion_prob.wr}
\alias{inclusion_prob.default}
\title{Inclusion Probabilities}
\usage{
inclusion_prob(x, ...)

\method{inclusion_prob}{wor}(x, ...)

\method{inclusion_prob}{wr}(x, ...)

\method{inclusion_prob}{default}(x, n, ...)
}
\arguments{
\item{x}{A numeric vector of positive size measures, or a
without-replacement design object (class \code{"wor"}).}

\item{...}{Additional arguments (currently unused).}

\item{n}{The desired sample size. Required when \code{x} is a numeric vector,
ignored when \code{x} is a design object.}
}
\value{
A numeric vector of inclusion probabilities. When applied to a
design object, returns the \strong{target} inclusion probabilities
(i.e., the \code{pik} vector passed to \code{\link[=unequal_prob_wor]{unequal_prob_wor()}}). For most
methods (\code{cps}, \code{brewer}, \code{systematic}, \code{poisson}), these are the
exact first-order inclusion probabilities of the design. For order
sampling methods (\code{sps}, \code{pareto}), the true first-order inclusion
probabilities are approximately but not exactly equal to the target
for finite populations; the discrepancy vanishes as N grows.
}
\description{
Compute inclusion probabilities from a size measure, or extract them
from a without-replacement design object.
}
\details{
When \code{x} is a numeric vector of size measures and \code{n} is provided,
computes \strong{exact} inclusion probabilities via an iterative
algorithm: initial probabilities \eqn{\pi_k = n x_k / \sum x_k} are
computed, then any unit with \eqn{\pi_k \ge 1} is set to 1 (certainty
selection) and the remaining probabilities are recomputed with a reduced
\eqn{n}. This process repeats until all probabilities are in \eqn{[0, 1]}.
The result always sums to exactly \eqn{n}.

This differs from \code{\link[=expected_hits]{expected_hits()}}, which uses simple proportional
allocation \eqn{n x_k / \sum x_k} without capping -- values can exceed 1.

Negative values in \code{x} are treated as zero (with a warning).
}
\examples{
# From size measures
size <- c(10, 20, 30, 40)
pik <- inclusion_prob(size, n = 2)
sum(pik)  # 2

# From a design object
s <- unequal_prob_wor(pik, method = "cps")
inclusion_prob(s)

# With certainty selections (large units)
size <- c(1, 1, 1, 100)
pik <- inclusion_prob(size, n = 2)
pik  # Unit 4 gets probability 1

}
\seealso{
\code{\link[=expected_hits]{expected_hits()}} for the with-replacement analogue,
\code{\link[=unequal_prob_wor]{unequal_prob_wor()}} for sampling with these probabilities.
}
